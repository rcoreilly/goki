// Copyright (c) 2018, Randall C. O'Reilly. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package ki

import (
	"bytes"
	"fmt"
	"log"
	"reflect"
	"strings"
)

// KiType provides JSON marshal / unmarshal with encoding of underlying type name
type KiType struct {
	T reflect.Type
}

// MarshalJSON saves only the type name
func (k KiType) MarshalJSON() ([]byte, error) {
	if k.T == nil {
		b := []byte("null")
		return b, nil
	}
	nm := "\"" + k.T.Name() + "\""
	b := []byte(nm)
	return b, nil
}

// UnmarshalJSON loads the type name and looks it up in the KiTypes registry of type names
func (k *KiType) UnmarshalJSON(b []byte) error {
	if bytes.Equal(b, []byte("null")) {
		k.T = nil
		return nil
	}
	tn := string(bytes.Trim(bytes.TrimSpace(b), "\""))
	// fmt.Printf("loading type: %v", tn)
	typ := KiTypes.FindType(tn)
	if typ == nil {
		return fmt.Errorf("KiType UnmarshalJSON: KiTypes type name not found: %v", tn)
	}
	k.T = typ
	return nil
}

////////////////////////////////////////////////////////////////////////////////////////
//   KiTypes TypeRegistry

// TypeRegistry is a map from type name to reflect.Type -- need to explicitly register each new type by calling AddType in the process of creating a new global variable, as in:
// 	var KiT_TypeName = ki.KiTypes.AddType(&TypeName{})
// 	where TypeName is the name of the type -- note that it is ESSENTIAL to pass a pointer
//  so that the type is considered addressable, even after we get Elem() of it
type TypeRegistry struct {
	Types map[string]reflect.Type
}

// KiTypes is master registry of types that embed Ki Nodes
var KiTypes TypeRegistry

// AddType adds a given type to the registry -- requires an empty object to grab type info from
func (tr *TypeRegistry) AddType(obj interface{}) reflect.Type {
	if tr.Types == nil {
		tr.Types = make(map[string]reflect.Type)
	}

	typ := reflect.TypeOf(obj).Elem()
	tr.Types[typ.Name()] = typ
	// fmt.Printf("added type: %v\n", typ.Name())
	return typ
}

// FindType finds a type based on its name -- returns nil if not found
func (tr *TypeRegistry) FindType(name string) reflect.Type {
	return tr.Types[name]
}

////////////////////////////////////////////////////////////////////////////////////////
//   KiEnums EnumRegistry and Enum [de]stringification support

// todo: suport bit-flag enums and composition of names as | of values, etc

// design notes: for methods that return string, not passing error b/c you can
// easily check for null string, and registering errors in log for setter
// methods, returning error and also logging so it is safe to ignore err if
// you don't care

// EnumRegistry is a map from an enum-style const int type name to a
// corresponding reflect.Type and conversion methods generated by (modified)
// stringer that convert to / from strings -- need to explicitly register each
// new type by calling AddEnum in the process of creating a new global
// variable, as in:
// var KiT_TypeName = ki.KiEnums.AddEnum(&TypeName{}, altStringMap)
// where TypeName is the name of the type and altStringMap is nil or a map[int64]string of
// alternative names for each enum value  OR:
// var KiT_TypeName = ki.KiEnums.AddEnumAltLowerRmPrefix(&TypeName{}, "Prefix", MyEnumN)
// which automatically registers alternative names as lower-case versions of const names with
// given prefix removed -- often what is used in e.g., json or xml kinds of formats
type EnumRegistry struct {
	Enums map[string]reflect.Type
	// optional alternative string map for enums -- e.g., lower-case, without prefixes etc -- can put multiple such alt strings in the one string with your own separator, in a predefined order, if necessary, and just call strings.Split on those and get the one you want
	AltStrings map[string]map[int64]string
}

// KiEnums is master registry of enum types -- can also create your own package-specific ones
var KiEnums EnumRegistry

// AddType adds a given type to the registry -- requires an empty object to
// grab type info from -- if no alternative strings map, then just passs nil
func (tr *EnumRegistry) AddEnum(obj interface{}, alts map[int64]string) reflect.Type {
	if tr.Enums == nil {
		tr.Enums = make(map[string]reflect.Type)
		tr.AltStrings = make(map[string]map[int64]string)
	}

	typ := reflect.PtrTo(reflect.TypeOf(obj)).Elem()
	tr.Enums[typ.Name()] = typ
	tr.AltStrings[typ.Name()] = alts
	// fmt.Printf("added enum: %v\n", typ.Name())
	return typ
}

// AddType adds a given type to the registry -- requires an empty object to
// grab type info from -- automatically initializes an alternative string map
// based on the name with given prefix removed (e.g., a type name-based prefix)
// and lower-cased -- also requires the last enum val -- assumes starts at 0
func (tr *EnumRegistry) AddEnumAltLowerRmPrefix(obj interface{}, prefix string, lastVal int64) reflect.Type {
	if tr.Enums == nil {
		tr.Enums = make(map[string]reflect.Type)
		tr.AltStrings = make(map[string]map[int64]string)
	}

	typ := reflect.PtrTo(reflect.TypeOf(obj)).Elem()
	alts := make(map[int64]string)
	for i := int64(0); i <= lastVal; i++ {
		str := EnumInt64ToString(i, typ)
		str = strings.ToLower(strings.TrimPrefix(str, prefix))
		// fmt.Printf("adding enum: %v\n", str)
		alts[i] = str
	}
	return tr.AddEnum(obj, alts)
}

// FindEnum finds an enum type based on its type name -- returns nil if not found
func (tr *EnumRegistry) FindEnum(name string) reflect.Type {
	return tr.Enums[name]
}

// EnumToInt64 converts an enum into an int64 using reflect -- just use int64(eval) when you
// have the enum in hand -- this is when you just have a generic item
func EnumToInt64(eval interface{}) int64 {
	if reflect.TypeOf(eval).Kind() == reflect.Ptr {
		eval = reflect.ValueOf(eval).Elem() // deref the pointer
	}
	var ival int64
	reflect.ValueOf(&ival).Elem().Set(reflect.ValueOf(eval).Convert(reflect.TypeOf(ival)))
	return ival
}

// set enum value from int64 value -- must pass a pointer to the enum and also needs raw type
// of the enum as well -- can't get it from the interface{} reliably
func EnumFromInt64(eval interface{}, ival int64, typ reflect.Type) error {
	if reflect.TypeOf(eval).Kind() != reflect.Ptr {
		err := fmt.Errorf("ki.EnumFromInt64: must pass a pointer to the enum: Type: %v, Kind: %v\n", reflect.TypeOf(eval).Name(), reflect.TypeOf(eval).Kind())
		log.Printf("%v", err)
		return err
	}
	reflect.ValueOf(eval).Elem().Set(reflect.ValueOf(ival).Convert(typ))
	return nil
}

// First convert an int64 to enum of given type, and then convert to string value
func EnumInt64ToString(ival int64, typ reflect.Type) string {
	// evpi, evi := NewEnumFromType(typ) // note: same code, but works here and not in fun..
	evnp := reflect.New(reflect.PtrTo(typ))
	evpi := evnp.Interface()
	evn := reflect.New(typ)
	evi := evn.Interface()
	evpi = &evi
	EnumFromInt64(evpi, ival, typ)
	return EnumToString(evi)
}

// Enum to String converts an enum value to its corresponding string value --
// you could just call fmt.Sprintf("%v") too but this is slightly faster
func EnumToString(eval interface{}) string {
	if reflect.TypeOf(eval).Kind() == reflect.Ptr {
		eval = reflect.ValueOf(eval).Elem() // deref the pointer
	}
	strer, ok := eval.(fmt.Stringer) // will fail if not impl
	if !ok {
		log.Printf("ki.EnumToString: fmt.Stringer interface not supported by type %v\n", reflect.TypeOf(eval).Name())
		return ""
	}
	return strer.String()
}

// note: convenience methods b/c it is easier to find on registry type

// Enum to String converts an enum value to its corresponding string value --
// you could just call fmt.Sprintf("%v") too but this is slightly faster
func (tr *EnumRegistry) EnumToString(eval interface{}) string {
	return EnumToString(eval)
}

// First convert an int64 to enum of given type, and then convert to string value
func (tr *EnumRegistry) EnumInt64ToString(ival int64, typ reflect.Type) string {
	return EnumInt64ToString(ival, typ)
}

// Enum to alternative String value converts an enum value to its
// corresponding alternative string value
func (tr *EnumRegistry) EnumToAltString(eval interface{}) string {
	if reflect.TypeOf(eval).Kind() == reflect.Ptr {
		eval = reflect.ValueOf(eval).Elem() // deref the pointer
	}
	et := reflect.TypeOf(eval)
	alts := tr.AltStrings[et.Name()]
	if alts == nil {
		log.Printf("ki.EnumToAltString: no alternative string map for type %v\n", et.Name())
		return ""
	}
	// convert to int64 for lookup
	ival := EnumToInt64(eval)
	return alts[ival]
}

// Enum to alternative String value converts an int64 to corresponding
// alternative string value, for given type name
func (tr *EnumRegistry) EnumInt64ToAltString(ival int64, typnm string) string {
	alts := tr.AltStrings[typnm]
	if alts == nil {
		log.Printf("ki.EnumInt64ToAltString: no alternative string map for type %v\n", typnm)
		return ""
	}
	return alts[ival]
}

// Enum from String Sets enum value from string -- must pass a *pointer* to
// the enum item. IMPORTANT: requires the modified stringer go generate utility
// that generates a StringToTypeName method
func SetEnumFromString(eptr interface{}, str string) error {
	etp := reflect.TypeOf(eptr)
	if etp.Kind() != reflect.Ptr {
		err := fmt.Errorf("ki.EnumFromString -- you must pass a pointer enum, not type: %v kind %v\n", etp, etp.Kind())
		log.Printf("%v", err)
		return err
	}
	et := etp.Elem()
	sv := reflect.ValueOf(str)
	methnm := "StringTo" + et.Name()
	meth := sv.MethodByName(methnm)
	if meth.IsNil() {
		err := fmt.Errorf("ki.EnumFromString: stringer-generated StringToX method not found: %v\n", methnm)
		log.Printf("%v", err)
		return err
	}
	args := make([]reflect.Value, 0, 1)
	args = append(args, sv)
	rv := meth.Call(args)
	reflect.ValueOf(eptr).Elem().Set(rv[0])
	return nil
}

// Set Enum from String Sets enum value from string -- must pass a *pointer* to
// the enum item. IMPORTANT: requires the modified stringer go generate utility
// that generates a StringToTypeName method
func (tr *EnumRegistry) SetEnumFromString(eptr interface{}, str string) error {
	return SetEnumFromString(eptr, str)
}

// Set  Enum from String using reflect.Value
// IMPORTANT: requires the modified stringer go generate utility
// that generates a StringToTypeName method
func SetEnumValueFromString(eval reflect.Value, str string) error {
	et := eval.Type()
	sv := reflect.ValueOf(str)
	methnm := "StringTo" + et.Name()
	meth := sv.MethodByName(methnm)
	if meth.IsNil() {
		err := fmt.Errorf("ki.EnumFromString: stringer-generated StringToX method not found: %v\n", methnm)
		log.Printf("%v", err)
		return err
	}
	args := make([]reflect.Value, 0, 1)
	args = append(args, sv)
	rv := meth.Call(args)
	eval.Set(rv[0])
	return nil
}

// Sets enum value from string, into a reflect.Value
// IMPORTANT: requires the modified stringer go generate utility
// that generates a StringToTypeName method
func (tr *EnumRegistry) SetEnumValueFromString(eval reflect.Value, str string) error {
	return SetEnumValueFromString(eval, str)
}

// Set Enum from alternative String -- must pass a *pointer* to the enum item.
func (tr *EnumRegistry) SetEnumFromAltString(eptr interface{}, str string) error {
	etp := reflect.TypeOf(eptr)
	if etp.Kind() != reflect.Ptr {
		err := fmt.Errorf("ki.EnumFromString -- you must pass a pointer enum, not type: %v kind %v\n", etp, etp.Kind())
		log.Printf("%v", err)
		return err
	}
	et := etp.Elem()
	alts := tr.AltStrings[et.Name()]
	if alts == nil {
		err := fmt.Errorf("ki.EnumFromAltString: no alternative string map for type %v\n", et.Name())
		log.Printf("%v", err)
		return err
	}
	for i, v := range alts {
		if v == str {
			reflect.ValueOf(eptr).Elem().Set(reflect.ValueOf(i).Convert(et))
			return nil
		}
	}
	err := fmt.Errorf("ki.EnumFromAltString: string: %v not found in alt list of strings for type%v\n", str, et.Name())
	log.Printf("%v", err)
	return err
}

// Set Enum from alternative String using a reflect.Value -- must pass a *pointer* to the enum item.
func (tr *EnumRegistry) SetEnumValueFromAltString(eval reflect.Value, str string) error {
	et := eval.Type()
	alts := tr.AltStrings[et.Name()]
	if alts == nil {
		err := fmt.Errorf("ki.SetEnumValueFromAltString: no alternative string map for type %v\n", et.Name())
		log.Printf("%v", err)
		return err
	}
	for i, v := range alts {
		if v == str {
			eval.Set(reflect.ValueOf(i).Convert(et))
			return nil
		}
	}
	err := fmt.Errorf("ki.SetEnumValueFromAltString: string: %v not found in alt list of strings for type%v\n", str, et.Name())
	log.Printf("%v", err)
	return err
}

// get a pointer and the enum itself as interface{}'s, based on the type
// todo: can't seem to get this to work -- just replicate the code per below
// func NewEnumFromType(typ reflect.Type) (interface{}, interface{}) {
// 	evnp := reflect.New(reflect.PtrTo(typ))
// 	evpi := evnp.Interface()
// 	evn := reflect.New(typ)
// 	evi := evn.Interface()
// 	evpi = &evi
// 	return evpi, evi
// }
